# 面向对象编程（中）

### 面向对象特征之二————继承性
 - 继承性的好处
    - 减少了代码的冗余，提高了代码的复用性、
    - 便于功能的扩展
    - 为之后多态性的使用，提供了前提
 - 继承类的格式
    -  class A extends B{}
    - A:子类、派生类、subclass
    - B:父类、超类、基类、superclass
 - Java中关于继承性的规定
    - 一个类可以被多个子类继承
    - Java中类的单继承性：一个类只能有一个父类
    
### 方法的重写
 - 子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作
 - 应用：重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法。
 - 重写的格式
 ```
 方法的声明： 权限修饰符  返回值类型  方法名(形参列表) throws 异常的类型{
  						//方法体
  					}
 ```
 - 重写的规定
    - 子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同
    - 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符    
    
      特殊情况：子类不能重写父类中声明为private权限的方法
    - 返回值类型：
       父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void  
       
       父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类  
       
       父类被重写的方法的返回值类型是基本数据类型(比如：double)，则子类重写的方法的返回值类型必须是相同的基本数据类型(必须也是double)
    - 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型（具体放到异常处理时候讲）
 - 子类和父类中的同名同参数的方法要么都声明为非static的（考虑重写），要么都声明为static的（不是重写）.

### 关键字————super
 - super理解为：父类的
 - super可以用来调用：属性、方法、构造器
 - super的使用：调用属性和方法
    - 我们可以在子类的方法或构造器中。通过使用"super.属性"或"super.方法"的方式，显式的调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略"super."
    - 特殊情况：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的使用"super.属性"的方式，表明调用的是父类中声明的属性。
    - 特殊情况：当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的使用"super.方法"的方式，表明调用的是父类中被重写的方法。
 - super调用构造器
    - 我们可以在子类的构造器中显式的使用"super(形参列表)"的方式，调用父类中声明的指定的构造器
    - "super(形参列表)"的使用，必须声明在子类构造器的首行！
    - 我们在类的构造器中，针对于"this(形参列表)"或"super(形参列表)"只能二选一，不能同时出现
    - 在构造器的首行，没有显式的声明"this(形参列表)"或"super(形参列表)"，则默认调用的是父类中空参的构造器：super()
    - 在类的多个构造器中，至少有一个类的构造器中使用了"super(形参列表)"，调用父类中的构造器

### 子类对象的实例化过程
 - 从结果上来看：（继承性）子类继承父类以后，就获取了父类中声明的属性或方法。  
    
    创建子类的对象，在堆空间中，就会加载所有父类中声明的属性。
 - 从过程上来看：当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，直到调用了java.lang.Object类中空参的构造器为止。正因为加载过所有的父类的结构，所以才可以看到内存中有父类中的结构，子类对象才可以考虑进行调用。
 - 明确：虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为new的子类对象。
 
### 面向对象的特征之三：多态性


### 练习

 - 继承性
```
public class ManKind {
	private int sex;
	private int salary;
	
	public ManKind() {
	}
	
	public ManKind(int sex, int salary) {
		this.sex = sex;
		this.salary = salary;
	}

	public void manOrWoman() {
		if(sex == 1) {
			System.out.println("man");
		}else if(sex == 0) {
			System.out.println("woman");
		}		
	}
	public void employeed() {
		String jobInfo = (salary == 0)? "no job" : "job";
		System.out.println(jobInfo);
	}
	public int getSex() {
		return sex;
	}
	public void setSex(int sex) {
		this.sex = sex;
	}
	public int getSalary() {
		return salary;
	}
	public void setSalary(int salary) {
		this.salary = salary;
	}	
}

public class Kids extends ManKind{
	private int yearsOld;
	
	public void printAge() {
		System.out.println("I am " + yearsOld + "years old");
	}

	public Kids() {
	}

	public Kids(int yearsOld) {
		this.yearsOld = yearsOld;
	}

	public int getYearsOld() {
		return yearsOld;
	}
	public void setYearsOld(int yearsOld) {
		this.yearsOld = yearsOld;
	}
}
public class KidsTest {
	public static void main(String args[]) {
		Kids someKid = new Kids(12);
		someKid.printAge();
		someKid.setSalary(0);
		someKid.setSex(1);
		someKid.employeed();
		someKid.manOrWoman();
	}
}
```
